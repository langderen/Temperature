C51 COMPILER V9.57.0.0   MAIN                                                              12/24/2025 13:18:22 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: E:\UV4\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main.lst
                    -) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <REGX52.H>
   2          #include "Timer0.h"
   3          #include "Key.h"
   4          #include "Nixie.h"
   5          #include "Delay.h"
   6          #include "AT24C02.h"
   7          #include "Buzzer.h"
   8          #include "DS18B20.h"
   9          #include "UART.h"
  10          #include <stdio.h>
  11          //波特率为9600
  12          unsigned char KeyNum;
  13          int Hour=0,Min=1,Sec=1,tmp;
  14          unsigned char RunFlag,Buzz=0;
  15          unsigned char index=0;
  16          float T;
  17          bit SendUARTFlag = 0;      // 1秒到时的发送标志
  18          char UART_Str[30];         // 足够容纳 "99:59:59 --> 99.99\r\n"
  19          void main()
  20          {
  21   1        
  22   1        Timer0_Init();
  23   1        UART_Init();
  24   1        DS18B20_ConvertT();   //上电先转换一次温度，防止第一次读数据错误
  25   1        Delay(1000);      //等待转换完成
  26   1        
  27   1        while(1)
  28   1        {
  29   2      
  30   2          tmp=(int)(T*100);
  31   2          KeyNum=Key();
  32   2      
  33   2          if(KeyNum==1)     //K1按键按下用于启动或暂停计时过程
  34   2          {
  35   3            RunFlag=!RunFlag; //启动标志位翻转
  36   3          }
  37   2          if(KeyNum==2)     //K2按键按下用于计时清零及系统复位
  38   2          { 
  39   3            RunFlag=0;
  40   3            Hour=0;         //分秒清0
  41   3            Min=1;        
  42   3            Sec=1;
  43   3            Buzz=0;         //暂停蜂鸣器
  44   3                  
  45   3            AT24C02_WriteByte(0,tmp/100);//温度计整数部分
  46   3            AT24C02_WriteByte(1,tmp%100);
  47   3      
  48   3          }
  49   2          if(KeyNum==3)     //K3按键按下用于切换计时档位
  50   2          {
  51   3            if(++index>2)index=0;
  52   3      
  53   3          }
  54   2          if(KeyNum==4&&!RunFlag)     //K4按键按下用于对当前计时时间进行逐次增加，最小步长
C51 COMPILER V9.57.0.0   MAIN                                                              12/24/2025 13:18:22 PAGE 2   

             -1
  55   2          {
  56   3            if(index==0)Sec++;
  57   3            else if(index==1)Min++;
  58   3            else Hour++;
  59   3            
  60   3            if(Sec >= 60) Sec = 0;
  61   3            if(Min >= 60) Min = 0;
  62   3            if(Hour >= 99) Hour = 0;
  63   3          }
  64   2          Nixie_SetBuf(1,Hour/10);  //设置显示缓存，显示数据
  65   2          Nixie_SetBuf(2,Hour%10);
  66   2          Nixie_SetBuf(3,11);
  67   2          Nixie_SetBuf(4,Min/10);
  68   2          Nixie_SetBuf(5,Min%10);
  69   2          Nixie_SetBuf(6,11);
  70   2          Nixie_SetBuf(7,Sec/10);
  71   2          Nixie_SetBuf(8,Sec%10);
  72   2          
  73   2          
  74   2          // 每1秒发送一次 UART 数据
  75   2          
  76   2          if(SendUARTFlag) {    
  77   3            // 关中断保护 DS18B20 时序
  78   3            EA = 0; 
  79   3            DS18B20_ConvertT(); // 转换温度
  80   3            T = DS18B20_ReadT(); // 读取温度
  81   3            EA = 1; // 恢复中断
  82   3                  
  83   3            SendUARTFlag = 0;  // 清标志
  84   3            sprintf(UART_Str, "%02d:%02d:%02d --> %d.%02dC\r\n",Hour, Min, Sec, tmp / 100, tmp % 100);
  85   3            ET0 = 0; // 临时关闭定时器0中断，停止按键扫描
  86   3            // ... 发送数据 ...
  87   3            UART_SendString(UART_Str);
  88   3            ET0 = 1; // 发送完毕，恢复中断
  89   3          }
  90   2        }
  91   1      }
  92          
  93          /**
  94            * @brief  秒表驱动函数，在中断中调用
  95            * @param  无
  96            * @retval 无
  97            */
  98          void Sec_Loop(void)
  99          {
 100   1        if(RunFlag==1)
 101   1        {
 102   2          Sec--;
 103   2          if(Sec<0)
 104   2          {
 105   3            Sec=59;
 106   3            Min--;
 107   3            if(Min<0)
 108   3            {
 109   4              Min=59;
 110   4              Hour--;
 111   4              if(Hour<0)
 112   4              { Hour=Min=Sec=0;
 113   5                RunFlag=0;
 114   5                Buzz=1;
 115   5              }
C51 COMPILER V9.57.0.0   MAIN                                                              12/24/2025 13:18:22 PAGE 3   

 116   4            }
 117   3          }
 118   2        }
 119   1      }
 120          
 121          void Timer0_Routine() interrupt 1
 122          {
 123   1        static unsigned int T0Count1,T0Count3;
 124   1        TL0 = 0x66;     
 125   1        TH0 = 0xFC;
 126   1        T0Count1++;
 127   1        if(T0Count1>=20)
 128   1        {
 129   2          T0Count1=0;
 130   2          Key_Loop(); //20ms调用一次按键驱动函数
 131   2        }
 132   1      
 133   1        Nixie_Loop();//2ms调用一次数码管驱动函数
 134   1        
 135   1        T0Count3++;
 136   1        if(T0Count3>=1000)
 137   1        {
 138   2          T0Count3=0;
 139   2          Sec_Loop(); //1s调用一次数秒表驱动函数
 140   2          SendUARTFlag=1;
 141   2        }
 142   1      
 143   1        if(Buzz)Buzzer_Time();
 144   1            
 145   1      }
 146          void UART_Routine() interrupt 4
 147          {
 148   1        if(RI==1)         //如果接收标志位为1，接收到了数据
 149   1        {
 150   2          RI=0;         //接收标志位清0
 151   2        }
 152   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    694    ----
   CONSTANT SIZE    =     30    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     50    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
